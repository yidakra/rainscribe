<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rainscribe - HLS Player with Subtitles</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.1.5"></script>
    <style>
        body {
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        video {
            width: 100%;
            height: auto;
            border-radius: 4px;
        }
        /* Explicit and stronger styling for video subtitles */
        video::cue {
            font-size: 1.5em;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-family: Arial, sans-serif;
            font-weight: bold;
            line-height: 1.5;
            text-shadow: 1px 1px 1px black;
        }
        .controls {
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        .language-selector {
            margin-top: 15px;
        }
        #status {
            color: #dc3545;
            margin: 10px 0;
        }
        .subtitle-option[disabled] {
            color: #999;
            font-style: italic;
        }
        #subtitle-debug {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
        }
        /* Custom subtitle container for when WebVTT doesn't work */
        #customSubtitles {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 1000;
            pointer-events: none;
        }
        .subtitle-text {
            display: inline-block;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 10px;
            margin: 0 auto;
            font-size: 1.5em;
            font-weight: bold;
            max-width: 80%;
            border-radius: 4px;
            line-height: 1.5;
            text-shadow: 1px 1px 1px black;
        }
        .player-wrapper {
            position: relative;
        }
        .time-offset-controls {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">rainscribe HLS Player</h1>
        <div class="player-container">
            <div class="player-wrapper">
                <video id="video" controls crossorigin="anonymous"></video>
                <div id="customSubtitles"></div>
            </div>
            
            <div class="controls">
                <div class="row">
                    <div class="col-md-6">
                        <div class="form-group">
                            <label for="subtitleLanguage">Subtitle Language</label>
                            <select id="subtitleLanguage" class="form-control">
                                <option value="ru">Russian</option>
                                <option value="en" class="subtitle-option" disabled>English (not available)</option>
                                <option value="nl" class="subtitle-option" disabled>Dutch (not available)</option>
                                <option value="disabled">Disabled</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="form-group time-offset-controls">
                            <label for="subtitleOffset">Subtitle Time Offset (seconds)</label>
                            <div class="input-group">
                                <input type="number" id="subtitleOffset" class="form-control" value="0" step="1">
                                <button id="applyOffset" class="btn btn-outline-secondary">Apply</button>
                            </div>
                            <small class="text-muted">Positive values delay subtitles, negative values show them earlier</small>
                        </div>
                    </div>
                </div>
                <div class="mt-3">
                    <button id="forceSubtitles" class="btn btn-sm btn-primary">Force Enable Subtitles</button>
                    <button id="useCustomSubtitles" class="btn btn-sm btn-success mx-2">Use Custom Subtitles</button>
                    <button id="showDebug" class="btn btn-sm btn-secondary">Toggle Debug Info</button>
                    <button id="reloadPlayer" class="btn btn-sm btn-warning">Reload Player</button>
                </div>
            </div>
            <div id="status"></div>
            <div id="subtitle-debug" class="mt-2" style="display: none;"></div>
        </div>
        
        <div class="mt-4">
            <h5>Stream Information</h5>
            <div id="streamInfo" class="p-3 bg-light">
                No stream loaded
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('video');
            const subtitleLanguageSelect = document.getElementById('subtitleLanguage');
            const streamInfo = document.getElementById('streamInfo');
            const statusDiv = document.getElementById('status');
            const subtitleDebug = document.getElementById('subtitle-debug');
            const forceSubtitlesBtn = document.getElementById('forceSubtitles');
            const showDebugBtn = document.getElementById('showDebug');
            const customSubtitlesContainer = document.getElementById('customSubtitles');
            const useCustomSubtitlesBtn = document.getElementById('useCustomSubtitles');
            const subtitleOffsetInput = document.getElementById('subtitleOffset');
            const applyOffsetBtn = document.getElementById('applyOffset');
            const reloadPlayerBtn = document.getElementById('reloadPlayer');
            
            let hls = null;
            let useCustomDisplay = false;
            let timeOffset = 0;
            let subtitleCues = [];
            let activeLanguage = 'ru';
            
            const MASTER_PLAYLIST_URL = '/hls/master.m3u8';
            
            // Debug logging
            function logDebug(message) {
                console.log(message);
                const time = new Date().toLocaleTimeString();
                subtitleDebug.innerHTML = `<div class="mb-1"><small class="text-muted">${time}</small> ${message}</div>` + subtitleDebug.innerHTML;
            }
            
            // Simplified player initialization to avoid the constructor error
            function initPlayer() {
                logDebug('Initializing HLS.js player');
                customSubtitlesContainer.innerHTML = '';
                statusDiv.innerText = '';
                
                // Destroy existing instance if any
                if (hls) {
                    hls.destroy();
                    hls = null;
                }
                
                try {
                    if (Hls.isSupported()) {
                        logDebug('HLS.js is supported in this browser');
                        
                        // Create new HLS instance with simpler config
                        hls = new Hls({
                            debug: false
                        });
                        
                        // Handle errors
                        hls.on(Hls.Events.ERROR, function(event, data) {
                            logDebug(`HLS Error: ${data.type} - ${data.details}`);
                            if (data.fatal) {
                                statusDiv.innerText = `Fatal Error: ${data.details}`;
                                
                                switch(data.type) {
                                    case Hls.ErrorTypes.NETWORK_ERROR:
                                        logDebug('Fatal network error, trying to recover...');
                                        hls.startLoad();
                                        break;
                                    case Hls.ErrorTypes.MEDIA_ERROR:
                                        logDebug('Fatal media error, trying to recover...');
                                        hls.recoverMediaError();
                                        break;
                                    default:
                                        logDebug('Fatal error, cannot recover');
                                        break;
                                }
                            }
                        });
                        
                        // Load source and attach media
                        logDebug(`Loading source: ${MASTER_PLAYLIST_URL}`);
                        hls.loadSource(MASTER_PLAYLIST_URL);
                        hls.attachMedia(video);
                        
                        // When manifest is parsed, autoplay
                        hls.on(Hls.Events.MANIFEST_PARSED, function(event, data) {
                            logDebug(`Manifest parsed: ${data.levels.length} levels`);
                            
                            // Update stream info with level details
                            data.levels.forEach((level, i) => {
                                logDebug(`Level ${i}: ${level.width}x${level.height}, ${level.bitrate} bitrate`);
                            });
                            
                            // Try to autoplay
                            video.play().catch(function(error) {
                                logDebug(`Autoplay prevented: ${error.message}`);
                                statusDiv.innerText = 'Click play to start video';
                            });
                            
                            updateStreamInfo();
                        });
                        
                        // Handle subtitle tracks when they are loaded
                        hls.on(Hls.Events.SUBTITLE_TRACKS_UPDATED, function(event, data) {
                            logDebug(`Subtitle tracks updated: ${JSON.stringify(data.subtitleTracks.map(t => t.name))}`);
                            updateStreamInfo();
                            
                            // Set Russian as default
                            setTimeout(function() {
                                updateSubtitles();
                            }, 500);
                        });
                        
                        // Load subtitle track details
                        hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, function(event, data) {
                            const fragmentCount = data.details && data.details.fragments ? data.details.fragments.length : 0;
                            logDebug(`Subtitle track loaded: ${data.id}, fragments: ${fragmentCount}`);
                            
                            if (fragmentCount > 0 && data.id !== undefined && hls.subtitleTracks) {
                                const track = hls.subtitleTracks[data.id];
                                if (track) {
                                    logDebug(`Subtitle track ${track.name} (${track.lang}) is available`);
                                    enableSubtitleOption(track.lang);
                                }
                            }
                        });
                    } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                        // For Safari which has native HLS support
                        logDebug('Using native HLS playback (Safari)');
                        video.src = MASTER_PLAYLIST_URL;
                        video.addEventListener('loadedmetadata', function() {
                            video.play().catch(function(error) {
                                logDebug(`Autoplay prevented: ${error.message}`);
                                statusDiv.innerText = 'Click play to start video';
                            });
                        });
                    } else {
                        logDebug('HLS is not supported in this browser');
                        statusDiv.innerText = 'HLS is not supported in your browser';
                    }
                } catch (error) {
                    logDebug(`Error initializing player: ${error.message}`);
                    statusDiv.innerText = `Error: ${error.message}`;
                }
                
                // Check text tracks after loading
                setTimeout(checkTextTracks, 3000);
            }
            
            // Display subtitles using custom element
            function displayCustomSubtitles() {
                if (!useCustomDisplay) return;
                
                const currentTime = video.currentTime - timeOffset;
                let activeTexts = [];
                
                // Find all cues that should be active at the current time
                for (const cue of subtitleCues) {
                    if (currentTime >= cue.startTime && currentTime <= cue.endTime) {
                        activeTexts.push(cue.text);
                    }
                }
                
                if (activeTexts.length > 0) {
                    // Display the active cues
                    customSubtitlesContainer.innerHTML = '';
                    const subtitleElement = document.createElement('div');
                    subtitleElement.className = 'subtitle-text';
                    subtitleElement.innerHTML = activeTexts.join('<br>');
                    customSubtitlesContainer.appendChild(subtitleElement);
                    
                    logDebug(`Displaying custom subtitle: ${activeTexts.join(' / ')}`);
                } else {
                    // Clear if no active cues
                    customSubtitlesContainer.innerHTML = '';
                }
            }
            
            // Check video text tracks
            function checkTextTracks() {
                if (!video) return;
                
                logDebug(`Video has ${video.textTracks.length} text tracks`);
                
                for (let i = 0; i < video.textTracks.length; i++) {
                    const track = video.textTracks[i];
                    logDebug(`Text track ${i}: kind=${track.kind}, language=${track.language}, label=${track.label}, mode=${track.mode}`);
                    
                    // Log active cues if any
                    if (track.activeCues && track.activeCues.length > 0) {
                        logDebug(`Active cues: ${track.activeCues.length}`);
                        for (let j = 0; j < track.activeCues.length; j++) {
                            logDebug(`Cue ${j} text: ${track.activeCues[j].text}`);
                        }
                    } else {
                        logDebug('No active cues');
                    }
                    
                    // If this is the current language track, check if it has any cues
                    if (track.language === activeLanguage) {
                        const hasAnyCues = track.cues && track.cues.length > 0;
                        logDebug(`Track has ${hasAnyCues ? track.cues.length : 0} total cues`);
                        
                        if (hasAnyCues) {
                            // Store cues for custom display
                            subtitleCues = [];
                            for (let j = 0; j < track.cues.length; j++) {
                                const cue = track.cues[j];
                                subtitleCues.push({
                                    startTime: cue.startTime,
                                    endTime: cue.endTime,
                                    text: cue.text
                                });
                                
                                // Log a few cues for debugging
                                if (j < 3) {
                                    logDebug(`Cue ${j}: start=${cue.startTime}, end=${cue.endTime}, text=${cue.text}`);
                                }
                            }
                        }
                    }
                }
                
                // Schedule another check
                setTimeout(checkTextTracks, 10000);
            }
            
            // Force enable all text tracks
            function forceEnableSubtitles() {
                logDebug('Forcing subtitles to be enabled');
                
                // First try HLS.js approach
                if (hls && hls.subtitleDisplay !== undefined) {
                    hls.subtitleDisplay = true;
                    logDebug('Set hls.subtitleDisplay = true');
                }
                
                // Also try direct text track manipulation
                for (let i = 0; i < video.textTracks.length; i++) {
                    const track = video.textTracks[i];
                    if (track.kind === 'subtitles' || track.kind === 'captions') {
                        if (track.language === subtitleLanguageSelect.value) {
                            track.mode = 'showing';
                            logDebug(`Set text track ${i} (${track.language}) to showing`);
                        } else {
                            track.mode = 'hidden';
                        }
                    }
                }
                
                // Check if we have a matching WebVTT URL and try to load directly
                const language = subtitleLanguageSelect.value;
                if (language !== 'disabled') {
                    toggleCustomSubtitles(true);
                }
                
                statusDiv.innerText = 'Forced subtitles to be visible';
                setTimeout(() => { statusDiv.innerText = ''; }, 3000);
            }
            
            // Toggle custom subtitle display
            function toggleCustomSubtitles(enable) {
                useCustomDisplay = enable;
                
                if (enable) {
                    useCustomSubtitlesBtn.textContent = 'Use Native Subtitles';
                    useCustomSubtitlesBtn.classList.remove('btn-success');
                    useCustomSubtitlesBtn.classList.add('btn-warning');
                    
                    // Add timeupdate listener for custom subtitle rendering
                    video.addEventListener('timeupdate', displayCustomSubtitles);
                    
                    logDebug('Switched to custom subtitle display');
                } else {
                    useCustomSubtitlesBtn.textContent = 'Use Custom Subtitles';
                    useCustomSubtitlesBtn.classList.remove('btn-warning');
                    useCustomSubtitlesBtn.classList.add('btn-success');
                    
                    // Remove timeupdate listener
                    video.removeEventListener('timeupdate', displayCustomSubtitles);
                    
                    // Clear custom subtitles
                    customSubtitlesContainer.innerHTML = '';
                    
                    logDebug('Switched to native subtitle display');
                }
                
                // Re-apply subtitle selection
                updateSubtitles();
            }
            
            // Update subtitle time offset
            function updateTimeOffset() {
                timeOffset = parseFloat(subtitleOffsetInput.value) || 0;
                logDebug(`Set subtitle time offset to ${timeOffset} seconds`);
                
                // Force update subtitles with new offset
                if (useCustomDisplay) {
                    displayCustomSubtitles();
                }
            }
            
            // Enable a subtitle option in the dropdown
            function enableSubtitleOption(language) {
                for (const option of subtitleLanguageSelect.options) {
                    if (option.value === language) {
                        option.disabled = false;
                        option.textContent = getLanguageName(language);
                        option.classList.remove('subtitle-option');
                        break;
                    }
                }
            }
            
            // Disable a subtitle option in the dropdown
            function disableSubtitleOption(language) {
                for (const option of subtitleLanguageSelect.options) {
                    if (option.value === language && language !== 'ru') {  // Always keep Russian enabled
                        option.disabled = true;
                        option.textContent = `${getLanguageName(language)} (not available)`;
                        option.classList.add('subtitle-option');
                        break;
                    }
                }
            }
            
            // Get language name from code
            function getLanguageName(code) {
                const names = {
                    'ru': 'Russian',
                    'en': 'English',
                    'nl': 'Dutch'
                };
                return names[code] || code.toUpperCase();
            }
            
            // Update subtitle track
            function updateSubtitles() {
                const language = subtitleLanguageSelect.value;
                activeLanguage = language !== 'disabled' ? language : '';
                
                if (!hls || !hls.subtitleTracks) {
                    logDebug('No subtitle tracks available yet');
                    return;
                }
                
                logDebug(`Updating subtitles to: ${language}`);
                
                // Handle native subtitle display
                if (!useCustomDisplay) {
                    if (language === 'disabled') {
                        logDebug('Disabling subtitles');
                        hls.subtitleDisplay = false;
                        
                        // Also disable all text tracks manually
                        for (let i = 0; i < video.textTracks.length; i++) {
                            video.textTracks[i].mode = 'disabled';
                        }
                        
                        // Clear custom subtitles container
                        customSubtitlesContainer.innerHTML = '';
                        return;
                    }
                    
                    // Enable subtitles display
                    hls.subtitleDisplay = true;
                    logDebug('Set hls.subtitleDisplay = true');
                    
                    // Find the subtitle track with the selected language
                    const trackIndex = hls.subtitleTracks.findIndex(track => track.lang === language);
                    
                    if (trackIndex !== -1) {
                        logDebug(`Selecting subtitle track ${trackIndex} (${language})`);
                        hls.subtitleTrack = trackIndex;
                        
                        // Also try direct text track manipulation as a fallback
                        for (let i = 0; i < video.textTracks.length; i++) {
                            const track = video.textTracks[i];
                            if (track.language === language) {
                                track.mode = 'showing';
                                logDebug(`Set text track ${i} (${language}) to showing`);
                            } else {
                                track.mode = 'hidden';
                            }
                        }
                    } else {
                        logDebug(`Subtitle track for language ${language} not found`);
                    }
                } else {
                    // For custom subtitle display, we'll use our stored cues
                    // and render them with the timeupdate event
                    logDebug('Using custom subtitle display, will render on timeupdate');
                    
                    // Disable native subtitle display
                    hls.subtitleDisplay = false;
                    
                    // Hide all text tracks
                    for (let i = 0; i < video.textTracks.length; i++) {
                        video.textTracks[i].mode = 'hidden';
                    }
                    
                    // Clear container if disabled
                    if (language === 'disabled') {
                        customSubtitlesContainer.innerHTML = '';
                    } else {
                        // Otherwise, immediately try to display any matching cues
                        displayCustomSubtitles();
                    }
                }
            }
            
            // Update stream info
            function updateStreamInfo() {
                if (!video) return;
                
                let info = '<h6>Video Stream:</h6>';
                
                if (hls && hls.levels && hls.levels.length > 0) {
                    const level = hls.levels[0]; // We only have one stream
                    info += `<p>Resolution: ${level.width}x${level.height}, Bitrate: ${(level.bitrate/1000000).toFixed(2)} Mbps</p>`;
                } else {
                    info += '<p>Loading video stream information...</p>';
                }
                
                info += '<h6>Available Subtitles:</h6><ul>';
                
                if (hls && hls.subtitleTracks && hls.subtitleTracks.length > 0) {
                    let availableCount = 0;
                    hls.subtitleTracks.forEach(track => {
                        const status = track.details && track.details.fragments && track.details.fragments.length > 0 
                            ? '<span class="text-success">✓ Available</span>' 
                            : '<span class="text-secondary">Loading or empty</span>';
                        info += `<li>${track.name} (${track.lang}): ${status}</li>`;
                        if (status.includes('Available')) availableCount++;
                    });
                    
                    if (availableCount === 0) {
                        info += '<li class="text-info">Only Russian subtitles are currently available</li>';
                    }
                } else {
                    info += '<li>Loading subtitle tracks...</li>';
                }
                
                info += '</ul>';
                
                // Video text tracks information
                info += '<h6>Video Text Tracks:</h6><ul>';
                if (video.textTracks.length > 0) {
                    for (let i = 0; i < video.textTracks.length; i++) {
                        const track = video.textTracks[i];
                        const cuesInfo = track.cues ? `, ${track.cues.length} cues` : '';
                        info += `<li>Track ${i}: ${track.label || track.language} (${track.kind}, mode: ${track.mode}${cuesInfo})</li>`;
                    }
                } else {
                    info += '<li>No text tracks available in video element</li>';
                }
                info += '</ul>';
                
                info += `<h6>Current Playback:</h6>`;
                info += `<p>Current Time: ${video.currentTime.toFixed(2)} seconds</p>`;
                info += `<p>Display Mode: ${useCustomDisplay ? 'Custom Subtitles' : 'Native Subtitles'}</p>`;
                info += `<p>Subtitle Offset: ${timeOffset} seconds</p>`;
                info += `<p>Player Status: ${video.paused ? 'Paused' : 'Playing'}</p>`;
                
                info += '<p class="mt-3 small text-muted">Note: English and Dutch subtitles may not be generated until content in those languages is available.</p>';
                
                streamInfo.innerHTML = info;
            }
            
            // Event listeners
            subtitleLanguageSelect.addEventListener('change', updateSubtitles);
            forceSubtitlesBtn.addEventListener('click', forceEnableSubtitles);
            showDebugBtn.addEventListener('click', function() {
                if (subtitleDebug.style.display === 'none') {
                    subtitleDebug.style.display = 'block';
                    showDebugBtn.textContent = 'Hide Debug Info';
                } else {
                    subtitleDebug.style.display = 'none';
                    showDebugBtn.textContent = 'Show Debug Info';
                }
            });
            useCustomSubtitlesBtn.addEventListener('click', function() {
                toggleCustomSubtitles(!useCustomDisplay);
            });
            applyOffsetBtn.addEventListener('click', updateTimeOffset);
            reloadPlayerBtn.addEventListener('click', function() {
                logDebug('Reloading player...');
                initPlayer();
            });
            
            // Update stream info periodically
            setInterval(updateStreamInfo, 5000);
            
            // Initialize player
            initPlayer();
            
            // Display debug info by default
            subtitleDebug.style.display = 'block';
            showDebugBtn.textContent = 'Hide Debug Info';
        });
    </script>
</body>
</html>